generator client {
  provider = "prisma-client-js"
  output   = "../generated/prisma"
}

datasource db {
  provider = "mysql"
  url      = env("DATABASE_URL") 
}

model User {
  id        Int      @id @default(autoincrement())
  name      String   @db.VarChar(100)
  email     String   @unique @db.VarChar(255)
  password  String   @db.VarChar(255) // Suporta hashes Argon2/BCrypt
  role      Role
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt
  
  donor     Donor?
  ong       Ong?
  admin     Admin?

  @@fulltext([name])
  @@map("users")
}

enum Role {
  donor
  ong
  admin
}

model Donor {
  userId    Int        @id @unique 
  user      User       @relation(fields: [userId], references: [id], onDelete: Cascade)
  cpf       String     @unique @db.VarChar(14)

  createdAt DateTime   @default(now())
  updatedAt DateTime   @updatedAt

  profile   DonorProfile?
  address   Address?
  donations Donation[]
  ratings   Rating[]

  @@map("donors")
}

model DonorProfile {
  id            Int      @id @default(autoincrement())
  bio           String?  @db.VarChar(500)
  avatarUrl     String?  @db.VarChar(255)
  contactNumber String?  @db.VarChar(20)
  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  donorId       Int      @unique
  donor         Donor    @relation(fields: [donorId], references: [userId], onDelete: Cascade)

  @@map("donor_profiles")
}

model Ong {
  userId             Int                @id @unique 
  user               User               @relation(fields: [userId], references: [id], onDelete: Cascade)
  cnpj               String             @unique @db.VarChar(18)
  verificationStatus VerificationStatus @default(pending)
  verifiedAt         DateTime?
  verifiedById       Int?
  rejectionReason    String?            @db.Text
  
  // Denormalização para performance de filtros e exibição
  averageRating      Float?             @default(0.0)
  numberOfRatings    Int                @default(0)

  createdAt          DateTime           @default(now())
  updatedAt          DateTime           @updatedAt

  // Relações
  profile            OngProfile?
  address            Address?
  ratings            Rating[]
  donations          Donation[]
  wishlistItems      WishlistItem[]
  verifiedBy         Admin?             @relation("OngVerifications", fields: [verifiedById], references: [userId], onDelete: SetNull)
  
  @@index([verificationStatus])
  @@map("ongs")
}

model OngProfile {
  id            Int      @id @default(autoincrement())
  bio           String?  @db.VarChar(500)
  avatarUrl     String?  @db.VarChar(255)
  contactNumber String?  @db.VarChar(20)
  websiteUrl    String?  @db.VarChar(255)
  categories    Category[]

  
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  ongId         Int      @unique
  ong           Ong      @relation(fields: [ongId], references: [userId], onDelete: Cascade)

  @@map("ong_profiles")
}

model Admin {
  userId                 Int   @id @unique 
  user                   User  @relation(fields: [userId], references: [id], onDelete: Cascade)
  
  // Relação inversa: ONGs verificadas por este admin
  verificationsPerformed Ong[] @relation("OngVerifications")

  @@map("admins")
}

model Address {
  id           Int      @id @default(autoincrement())
  street       String   @db.VarChar(255)
  number       String   @db.VarChar(20)
  complement   String?  @db.VarChar(255)
  neighborhood String   @db.VarChar(100)
  city         String   @db.VarChar(100)
  state        String   @db.VarChar(2)
  zipCode      String   @db.VarChar(10)
  country      String   @default("Brasil") @db.VarChar(100)
  
  createdAt    DateTime @default(now())
  updatedAt    DateTime @updatedAt

  donorId      Int?     @unique
  ongId        Int?     @unique
  
  donor        Donor?   @relation(fields: [donorId], references: [userId], onDelete: Cascade)
  ong          Ong?     @relation(fields: [ongId], references: [userId], onDelete: Cascade)

  @@map("addresses")
}

enum VerificationStatus {
  pending
  verified
  rejected
}

model Donation {
  id                  Int            @id @default(autoincrement())
  donationType        DonationType
  donationStatus      DonationStatus @default(pending)
  
  // Decimal para precisão financeira (MySQL Decimal 10,2)
  monetaryAmount      Decimal?       @db.Decimal(10, 2)
  monetaryCurrency    String?        @db.VarChar(3)
  
  proofOfPaymentUrl   String?        @db.VarChar(255)
  materialDescription String?        @db.Text
  materialQuantity    Int?
  
  donorId             Int
  ongId               Int
  
  createdAt           DateTime       @default(now())
  updatedAt           DateTime       @updatedAt
  verifiedAt          DateTime?
  
  donor               Donor          @relation(fields: [donorId], references: [userId], onDelete: Cascade)
  ong                 Ong            @relation(fields: [ongId], references: [userId], onDelete: Cascade)

  @@index([donorId])
  @@index([ongId])
  @@index([donationStatus])
  @@map("donations")
}

enum DonationStatus {
  pending
  completed
  canceled
}

enum DonationType {
  monetary
  material
}

model WishlistItem {
  id          Int      @id @default(autoincrement())
  description String   @db.VarChar(255)
  quantity    Int
  
  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  ongId       Int
  ong         Ong      @relation(fields: [ongId], references: [userId], onDelete: Cascade)

  @@map("wishlist_items")
}

model Rating {
  id        Int      @id @default(autoincrement())
  score     Int      // Recomendado validar no NestJS (1 a 5)
  comment   String?  @db.Text
  
  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  ongId     Int
  donorId   Int

  ong       Ong      @relation(fields: [ongId], references: [userId], onDelete: Cascade)
  donor     Donor    @relation(fields: [donorId], references: [userId], onDelete: Cascade)

  // Garante que um doador avalie uma ONG apenas uma vez
  @@unique([ongId, donorId])
  
  // Índices para performance de busca e agregação (AVG/COUNT)
  @@index([ongId])
  @@index([donorId])
  
  @@map("ratings")
}

model Category {
  id          Int      @id @default(autoincrement())
  name        String   @unique @db.VarChar(100)
  profiles    OngProfile[]

  createdAt   DateTime @default(now())
  updatedAt   DateTime @updatedAt

  @@fulltext([name])
  @@map("categories")
}

model PasswordResetToken {
  id        String   @id @default(cuid())
  email     String   @db.VarChar(255)
  tokenHash String   @unique @db.VarChar(255)
  expiresAt DateTime
  used      Boolean  @default(false)
  usedAt    DateTime?

  createdAt DateTime @default(now())

  @@index([email])
  @@index([expiresAt])
  @@map("password_reset_tokens")
}